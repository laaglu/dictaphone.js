/**********************************************
 * Copyright (C) 2014 Lukas Laag
 * This file is part of dictaphone.js.
 * 
 * dictaphone.js is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * dictaphone.js is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with dictaphone.js.  If not, see http://www.gnu.org/licenses/
 **********************************************/

'use strict';

/*global Backbone, moment, RSVP*/

var dbconfig = require('./dbconfig');
var samples = require('./Samples');
var logger = require('Logger');

/*
 name : (string) The recording name,
 duration: (number) The clip duration in s
 totalSize: (number) The byte size of the clip for a single channel
 sampleSize: (number) The byte size of a sample for a single channel
 sampleRate: (number) The sample rate
 creationDate: (number) The recording creation date (in ms since epoch)
 lastPlayed : (number) The play date (in ms since epoch, -1 if never played)
 */
var ClipModel = Backbone.Model.extend({
  database: dbconfig,
  storeName: 'clip',
  defaults : {
    // Set creation date to now
    creationDate : Date.now(),
    totalSize:0,
    duration:0
  },
  initialize: function initialize() {
  },
  sampleLength: function sampleLength() {
    return this.get('sampleSize') / this.get('sampleRate');
  },
  getCreationDate : function getCreationDate() {
    return moment(+this.get('creationDate')).format('lll');
  },
  getDuration: function getDuration() {
    var duration, ms, format;

    duration = this.get('duration');
    ms = ~~(duration * 1000);
    if (ms < 60000) {
      format = 's.S';
    } else if (ms < 3600000) {
      format = 'm:ss.S';
    } else {
      format = 'H:mm:ss.S';
    }
    return moment.utc(ms).format(format);
  },

  /**
   * Delete the specified samples from a clip
   * status: { Object } a status object generated by samples.getCount
   */
  terminate : function terminate(status) {
    logger.log('terminate', status);
    var self = this,
      sampleSize = self.get('sampleSize'),
      totalSize = self.get('totalSize'),
      step = 50 * sampleSize, // Delete 50 samples at a time
      from = -step;
    return new RSVP.Promise(function(resolve) {
        self.destroy({
          success: function() {
            if (status) { status.clipCount--; }
            resolve();
          },
          error: function(err) {
            logger.error(err);
            resolve(); // keep going
          }
        });
      })
    .then(function partialDelete() {
      from = Math.min(totalSize, from + step);
      if (from === totalSize) {
        return;
      }
      return samples.deleteSamples({
        clipid: self.id,
        from: from,
        to: Math.min(totalSize, from + step),
      }).then(function(count) {
        if (status && count) {
          status.sampleCount -= count;
        }
        return partialDelete();
      });
    });
  },
  getSampleCount: function getSampleCount() {
    return ~~(this.get('totalSize') / this.get('sampleSize'));
  }

});
module.exports = ClipModel;
