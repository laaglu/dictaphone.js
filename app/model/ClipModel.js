/**********************************************
 * Copyright (C) 2014 Lukas Laag
 * This file is part of dictaphone.js.
 * 
 * dictaphone.js is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * dictaphone.js is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with dictaphone.js.  If not, see http://www.gnu.org/licenses/
 **********************************************/

'use strict';

/*global Backbone, moment*/

var dbconfig = require('./dbconfig');
var samples = require('./Samples');
var logger = require('Logger');

/*
 name : (string) The recording name,
 duration: (number) The clip duration in s
 totalSize: (number) The byte size of the clip for a single channel
 sampleSize: (number) The byte size of a sample for a single channel
 sampleRate: (number) The sample rate
 creationDate: (number) The recording creation date (in ms since epoch)
 lastPlayed : (number) The play date (in ms since epoch, -1 if never played)
 */
var ClipModel = Backbone.Model.extend({
  database: dbconfig,
  storeName: 'clip',
  defaults : {
    // Set creation date to now
    creationDate : Date.now(),
    totalSize:0,
    duration:0
  },
  initialize: function() {
  },
  sampleLength: function() {
    return this.get('sampleSize') / this.get('sampleRate');
  },
  getCreationDate : function() {
    return moment(+this.get('creationDate')).format('lll');
  },
  getDuration: function() {
    var duration, ms, format;

    duration = this.get('duration');
    ms = ~~(duration * 1000);
    if (ms < 60000) {
      format = 's.S';
    } else if (ms < 3600000) {
      format = 'm:ss.S';
    } else {
      format = 'H:mm:ss.S';
    }
    return moment.utc(ms).format(format);
  },

  /**
   * Delete the specified samples from a clip
   * @param options
   * success: { function } a callback to invoke once deletion is complete
   * error: { function } a callback to invoke upon error
   * status: { Object } a status object generated by samples.getCount
   */
  terminate : function(options) {
    var sampleSize = this.get('sampleSize'),
      totalSize = this.get('totalSize'),
      step = 50 * sampleSize, // Delete 50 samples at a time
      from = -step,

      partialDelete = function partialDelete() {
        from = Math.min(totalSize, from + step);
        if (from === totalSize) {
          if (typeof options.success === 'function' ) {
            options.success();
          }
          return;
        }
        var deleteOptions = {
          clipid: this.id,
          from: from,
          to: Math.min(totalSize, from + step),
          success: scheduleNextDelete,
          error: logger.logAndProceed(scheduleNextDelete)
        };
        samples.deleteSamples(deleteOptions);
      }.bind(this),

      scheduleNextDelete = function scheduleNextDelete(count) {
        if (options.status && count) {
          options.status.sampleCount -= count;
        }
        setTimeout(partialDelete);
      };
    this.destroy({
      success: function() {
        if (options.status) {
          options.status.clipCount--;
        }
        scheduleNextDelete();
      },
      error: typeof options.error === 'function' ? logger.logAndProceed(options.error) : logger.error
    });

  },
  getSampleCount: function() {
    return ~~(this.get('totalSize') / this.get('sampleSize'));
  },
  isPlaying: function isPlaying() {
    return this.player && this.player.playing;
  },
  isRecording: function isRecording() {
    return this.recorder && this.recorder.recording;
  },
  isExporting: function isExporting() {
    return this.exporter && this.exporter.exporting;
  }
});
module.exports = ClipModel;
