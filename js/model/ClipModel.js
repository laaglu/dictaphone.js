define(['backbone', 'model/dbconfig', 'model/Samples', 'moment', 'Logger'],
  function(Backbone, dbconfig, samples, moment, logger) {

    "use strict";

    /*
     name : (string) The recording name,
     duration: (number) The clip duration in s
     totalSize: (number) The byte size of the clip for a single channel
     sampleSize: (number) The byte size of a sample for a single channel
     sampleRate: (number) The sample rate
     creationDate: (number) The recording creation date (in ms since epoch)
     lastPlayed : (number) The play date (in ms since epoch, -1 if never played)
     */
    var ClipModel = Backbone.Model.extend({
      database: dbconfig,
      storeName: 'clip',
      defaults : {
        // Set creation date to now
        creationDate : Date.now(),
        totalSize:0,
        duration:0
      },
      initialize: function() {
      },
      sampleLength: function() {
        return this.get('sampleSize') / this.get('sampleRate');
      },
      getCreationDate : function() {
        return moment(+this.get('creationDate')).format('lll');
      },
      getDuration: function() {
        var duration = [];
        var t = this.get('duration');
        var s = ~~t;
        var d = ~~(s / (24 * 3600));
        if (d > 0) {
          duration.push(d);
          duration.push(' d');
        }
        s -= d * 24 * 3600;
        var h = ~~(s / 3600);
        if (d > 0 || h > 0) {
          duration.push(h);
          duration.push('h ');
          s -= h * 3600;
        }
        var m = ~~(s / 60);
        if (d > 0 || h > 0 || m > 0) {
          duration.push(m);
          duration.push('m ');
        }
        s = s % 60;
        duration.push(s);
        var ms = ~~((t - Math.floor(t))*10);
        duration.push('.');
        duration.push(ms);

        duration.push('s');
        return duration.join('');
      },

      /**
       * Delete the specified samples from a clip
       * @param options
       * success: { function } a callback to invoke once deletion is complete
       * error: { function } a callback to invoke upon error
       * status: { Object } a status object generated by samples.getCount
       */
      terminate : function(options) {
        var sampleSize = this.get('sampleSize'),
          totalSize = this.get('totalSize'),
          step = 50 * sampleSize, // Delete 50 samples at a time
          from = -step,

          partialDelete = function partialDelete() {
            from = Math.min(totalSize, from + step);
            if (from === totalSize) {
              if (typeof options.success === 'function' ) {
                options.success();
              }
              return;
            }
            var deleteOptions = {
              clipid: this.id,
              from: from,
              to: Math.min(totalSize, from + step),
              success: scheduleNextDelete,
              error: logger.logAndProceed(scheduleNextDelete)
            };
            samples.deleteSamples(deleteOptions);
          }.bind(this),

          scheduleNextDelete = function scheduleNextDelete(count) {
            if (options.status && count) {
              options.status.sampleCount -= count;
            }
            setTimeout(partialDelete);
          };
        this.destroy({
          success: function() {
            if (options.status) {
              options.status.clipCount--;
            }
            scheduleNextDelete();
          },
          error: typeof options.error === 'function' ? logger.logAndProceed(options.error) : logger.error
        });

      },
      getSampleCount: function() {
        return ~~(this.get('totalSize') / this.get('sampleSize'));
      },
      isPlaying: function isPlaying() {
        return this.player && this.player.playing;
      },
      isRecording: function isRecording() {
        return this.recorder && this.recorder.recording;
      }
    });
    return ClipModel;
  }
);